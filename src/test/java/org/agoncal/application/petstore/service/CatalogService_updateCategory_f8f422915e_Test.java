/*
Test generated by RoostGPT for test petstoredemo2 using AI Type Open AI and AI Model gpt-4

1. **Scenario:** Verify that the function `updateCategory` updates the category correctly when a valid `Category` object is passed.
   - **Test Steps:** 
     - Create a `Category` object with valid values and save it in the database.
     - Update one or more field(s) of the `Category` object.
     - Call the `updateCategory` function with the updated `Category` object.
     - Fetch the updated `Category` object from the database.
   - **Expected Result:** The fetched `Category` object should reflect the updates.

2. **Scenario:** Verify that the function `updateCategory` does not allow updating the category with null values.
   - **Test Steps:** 
     - Create a `Category` object with valid values and save it in the database.
     - Update one or more field(s) of the `Category` object to null.
     - Call the `updateCategory` function with the updated `Category` object.
   - **Expected Result:** The function should throw a validation exception, and the original `Category` object in the database should remain unchanged.

3. **Scenario:** Verify that the function `updateCategory` handles non-existent categories correctly.
   - **Test Steps:** 
     - Create a `Category` object with valid values but do not save it in the database.
     - Call the `updateCategory` function with this `Category` object.
   - **Expected Result:** The function should throw an exception, indicating that the category does not exist.

4. **Scenario:** Verify that the function `updateCategory` works correctly with large data.
   - **Test Steps:** 
     - Create a `Category` object with valid values and a large number of associated `Item` and `Product` objects. Save this `Category` object in the database.
     - Update one or more field(s) of the `Category` object.
     - Call the `updateCategory` function with the updated `Category` object.
     - Fetch the updated `Category` object from the database.
   - **Expected Result:** The fetched `Category` object should reflect the updates, and all associated `Item` and `Product` objects should remain correctly linked.

5. **Scenario:** Verify that the function `updateCategory` handles concurrent updates correctly.
   - **Test Steps:** 
     - Create a `Category` object with valid values and save it in the database.
     - In two separate threads, update different fields of the `Category` object and call the `updateCategory` function.
     - Fetch the updated `Category` object from the database.
   - **Expected Result:** The fetched `Category` object should reflect the updates from both threads.
*/package org.agoncal.application.petstore.service;

import org.agoncal.application.petstore.model.Category;
import org.junit.Before;
import org.junit.Test;
import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;
import javax.validation.ValidationException;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Mockito.*;

public class CatalogService_updateCategory_f8f422915e_Test {

    private CatalogService catalogService;
    private EntityManager em;

    @Before
    public void setup() {
        catalogService = new CatalogService();
        em = mock(EntityManager.class);
        // Use reflection to set the private field 'em' in 'catalogService'
        try {
            java.lang.reflect.Field field = catalogService.getClass().getDeclaredField("em");
            field.setAccessible(true);
            field.set(catalogService, em);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testUpdateCategory() {
        Category category = new Category();
        category.setName("Dogs");

        when(em.merge(category)).thenReturn(category);

        Category updatedCategory = catalogService.updateCategory(category);
        verify(em).merge(category);
        assertEquals("Dogs", updatedCategory.getName());
    }

    @Test(expected = ValidationException.class)
    public void testUpdateCategoryWithNull() {
        Category category = new Category();
        category.setName(null);

        when(em.merge(category)).thenThrow(ValidationException.class);
        catalogService.updateCategory(category);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testUpdateNonExistentCategory() {
        Category category = new Category();
        category.setName("Cats");

        when(em.merge(category)).thenThrow(IllegalArgumentException.class);
        catalogService.updateCategory(category);
    }

    @Test
    public void testUpdateCategoryWithLargeData() {
        Category category = new Category();
        category.setName("Birds");

        TypedQuery query = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(Category.class))).thenReturn(query);
        when(query.getSingleResult()).thenReturn(category);
        when(em.merge(category)).thenReturn(category);

        Category updatedCategory = catalogService.updateCategory(category);
        verify(em).merge(category);
        assertEquals("Birds", updatedCategory.getName());
    }

    @Test
    public void testConcurrentUpdateCategory() throws InterruptedException {
        Category category = new Category();
        category.setName("Fish");

        when(em.merge(category)).thenReturn(category);

        Thread t1 = new Thread(() -> catalogService.updateCategory(category));
        Thread t2 = new Thread(() -> catalogService.updateCategory(category));

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        verify(em, times(2)).merge(category);
    }
}
